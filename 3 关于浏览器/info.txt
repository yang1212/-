* 浏览器渲染机制
    https://segmentfault.com/a/1190000010298038
    https://www.cnblogs.com/caizhenbo/p/6679478.html

* 浏览器是怎么工作的
    https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/
    
* 五大主流浏览器内核的源起以及国内各大浏览器内核总结
    https://blog.csdn.net/Summer_15/article/details/71249203

* 从输入 url 到展示的过程  
    https://www.cnblogs.com/Tiboo/p/12317123.html

* 重绘与回流
    https://www.cnblogs.com/Tiboo/p/10505613.html

* 存储
    https://www.cnblogs.com/Tiboo/p/10355955.html

* Web Worker
    http://www.ruanyifeng.com/blog/2018/07/web-worker.html   

* V8垃圾回收机制 
    https://juejin.im/post/5c8b89f55188257e8e232d99

* 内存泄露
    内存泄露是指new了一块内存，但无法被释放或者被垃圾回收(https://juejin.im/post/5b2fd09ee51d45588576f429)
    造成内存泄露的可能会有以下几种情况：
      1）监听在window/body等事件没有解绑
      2）绑在EventBus的事件没有解绑
      3）Vuex的$store watch了之后没有unwatch
      4）模块形成的闭包内部变量使用完后没有置成null
      5）使用第三方库创建，没有调用正确的销毁函数    

* 为了性能做过哪些事？
    
    页面级别优化：
      1 减少http请求数是最重要也是最有效的方法
      2 压缩字体文字，压缩图片;

    代码级别优化：
      1  结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载
         我们可以在router中进行配置, 实现组件的按需加载, 在一些单个组件文件较大的时候, 
         采用按需加载能够减少build.js的体积, 优化加载速度(如果组件的体积较小, 那么采用
         按需加载会增加额外的http请求, 反倒增加了加载时间)。
         https://router.vuejs.org/zh/guide/advanced/lazy-loading.html
      2 模块按需加载，如引入第三方共用组件
      3 关注代码质量,如遍历;
      4 尽可能避免页面回流，合理规范场景，如常见的v-if

    补充还可以做哪些事：
    https://www.cnblogs.com/xiaohuochai/p/9178390.html

* 浏览器的多进程到JS的单线程
  https://segmentfault.com/a/1190000012925872
