* 原型/构造函数/实例
  https://www.cnblogs.com/Tiboo/p/11296979.html

* 闭包
  1 闭包就是能够读取其他函数内部变量的函数
  2 定义在一个函数内部的函数
  http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html

* this的指向练习，以及通过函数执行改变this指向知识点
  https://github.com/YvetteLau/Blog/issues/6
 
* new运算符的执行过程 
  1 创建一个新对象
  2 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）
  3 执行构造函数中的代码（为这个新对象添加属性）
  4 返回新对象

* 类型转换
  显式类型转换
  隐式类型转换 (可大量训练特殊值，了解规则)
  https://juejin.im/post/5b6906b46fb9a04fcb5b8771

* 防抖与节流
  https://www.cnblogs.com/Tiboo/p/11795788.html

* AST(抽象语法树) & babel编译原理
  https://juejin.im/post/5ab9f2f3f265da239b4174f0#heading-9

* 函数柯里化
  https://www.cnblogs.com/Tiboo/p/10633469.html  

* 跨域
  1 跨域调用接口，并写入cookie值
      基于跨域资源共享（CORS)
      运维设置：Access-Control-Allow-Credentials为true, Access-Control-Allow-Origin 字段必须指定域名
               （Access-Control-Allow-Credentials: 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie）
               （发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名）  

      前端设置：CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，
               指定Access-Control-Allow-Credentials字段。另一方面，开发者必须在AJAX请求中打开withCredentials属性。
               即设置：axios.defaults.withCredentials = true(基于Vue)

  2 跨域调用第三方接口数据
      node作为中间层实现跨域，因为服务器之间是不存在跨域问题的
      https://juejin.im/post/5a2f92c65188253e2470f16d
      

* 数组去重的几种方式 (性能由差到好)
  1） 双重 for 循环
  2） Array.filter() + indexOf
  3） Array.sort()
  4） new Set()
  5） for...of + Object
  https://www.cnblogs.com/wisewrong/p/9642264.html
  https://www.cnblogs.com/Tiboo/p/11846316.html

* 前端安全
  1） XSS攻击(跨站脚本攻击)
  2） CSRF攻击(跨站请求伪造)
  3） 网络劫持攻击
  4） 控制台注入代码
  5） 钓鱼
  https://tech.meituan.com/2018/09/27/fe-security.html
  https://segmentfault.com/a/1190000006672214
  https://zhuanlan.zhihu.com/p/25486768?group_id=820705780520079360
  https://www.tuicool.com/articles/7Ff2EbZ

* Ajax
  AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。
  readyState状态：0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪

  var url = "http://yapi.demo.qunar.com/mock/37644/testDat";
  var a = new XMLHttpRequest();
  a.open("get", url);
  a.send(); 
  a.onreadystatechange = function () {
    if (a.readyState === 4 && a.status == 200) {
      console.log(a, a.responseText)
    }
  }  

* 判断值
  1) 是否为数组
     instanceof/contructor 常用，偶尔不准确？/假定一个全局环境，iframe引入后
     Array.isArray(value) 兼容性不够强大
     Object.prototype.toString.call(o) 最稳
     https://juejin.im/post/5be52b1ae51d450b3647e766#heading-2
  2) 是否为对象
     instanceof
     Object.prototype.toString.call(o) 最稳
  3) 是否为function
     instanceof
     Object.prototype.toString.call(o) 最稳
  4) 是否为基本类型
     Object.prototype.toString.call(o) 最稳
     除了null, typeof可判断剩下的基本数据类型

* 什么是高阶函数
  JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，
  那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数  

* 静态作用域&动态作用域
  静态：静态作用域（即词法作用域）中的 函数 遇到既不是形参也不是函数内部定义的局部变量的变量时，会去函数 定义 时的环境中查询。
  eg:
    function foo(){ console.log(a) }
    function bar(){
      var a = 3;
      function fn() { console.log(a) }
      return fn()
    }
    var a = 2;
    bar();
  动态：动态作用域中的 函数 遇到既不是形参也不是函数内部定义的局部变量的变量时，到函数 调用 时的环境中查。
    

    